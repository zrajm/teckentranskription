#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;

# Use UTF8 for EVERYTHING.
use utf8;
use open qw(:std :utf8);
@ARGV = do {
    use Encode qw(decode_utf8);
    map { decode_utf8($_, 1) } @ARGV;
};

die "Usage: $0 DIR <INPUT >OUTPUT\n" if @ARGV == 0;
(my $dir = shift()) =~ s#/+$##;
if (not -d ($dir // '')) {
    die("$0: First arg must be a dir with HTML files fetched ",
        "from teckensprakslexikon.su.se\n");
}

################################################################################

sub read_file {
    my ($file) = @_;
    local $/ = undef;
    open(my $in, '<', $file) or die "Cannot open file '$file' for reading\n";
    return <$in>;
}

################################################################################

my %words;
my @html_files = <$dir/?????>;
my $count = 0;
foreach my $file (@html_files) {
    my $html = read_file($file);

    printf STDERR "Reading HTML input files: %s%%\r", int((($count + 1) / @html_files) * 100);

    my ($word) = $html =~ m#<h2>(.*?)</h2>#;
    if ($word) {
        for ($word) {
            s/\s{2,}/ /g;
            s{\s*<span class="also_means">\s*(.*?)</span>}{ $1 ? ", $1" : "" }e;
            $word = lc($_) if not /^..*[[:upper:]]/;
        }

        my ($id) = $file =~ m#.*/(\d{5})#;

        $words{$id} = $word;
    }
    $count += 1;
}

foreach my $id (sort keys %words) {
    print "$id:$words{$id}\n";
}

#[eof]
